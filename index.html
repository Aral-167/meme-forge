<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Meme Forge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      margin: 0; padding: 24px; max-width: 1200px; margin: 0 auto;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; color: #333;
    }
    h1 { 
      text-align: center; color: white; font-size: 2.5em; margin-bottom: 8px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .subtitle {
      text-align: center; color: rgba(255,255,255,0.9); margin-bottom: 32px;
      font-size: 1.1em; font-weight: 300;
    }
    .row { display: grid; gap: 24px; grid-template-columns: 1fr 1fr }
    .card { 
      background: white; border-radius: 16px; padding: 24px; 
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
    }
    .card h3 { margin-top: 0; color: #444; font-size: 1.4em; }
    canvas, img { 
      max-width: 100%; border-radius: 12px; 
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
      border: 2px solid #f0f0f0;
    }
    input, select, button { 
      padding: 12px 16px; border-radius: 12px; border: 2px solid #e1e5e9;
      font-size: 14px; transition: all 0.2s ease;
      width: 100%; margin-bottom: 12px;
    }
    input:focus, select:focus {
      outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
    }
    button { 
      cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white; border: none; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.5px; transition: all 0.2s ease;
    }
    button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102,126,234,0.3); }
    button:active { transform: translateY(0); }
    button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    .hidden { display: none }
    .likes { 
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
      padding: 12px 0; border-top: 1px solid #f0f0f0; margin-top: 12px;
    }
    .likes button {
      padding: 8px 12px; margin: 0; width: auto; font-size: 13px;
      text-transform: none; letter-spacing: normal;
    }
    .likes strong { color: #667eea; font-size: 16px; }
    .toolbar { 
      display: flex; justify-content: flex-end; margin-bottom: 24px;
    }
    .toolbar button {
      background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);
      backdrop-filter: blur(10px); width: auto; margin: 0;
    }
    .toolbar button:hover {
      background: rgba(255,255,255,0.3);
    }
    .secondary-btn {
      background: #f8f9fa !important; color: #666 !important; 
      border: 2px solid #e9ecef !important;
    }
    .secondary-btn:hover {
      background: #e9ecef !important; transform: translateY(-1px);
    }
    .danger-btn {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%) !important;
    }
    .danger-btn:hover {
      box-shadow: 0 6px 20px rgba(255,107,107,0.3);
    }
    label {
      display: block; margin-bottom: 8px; font-weight: 600; color: #555;
    }
    .form-group {
      margin-bottom: 20px;
    }
    .button-group {
      display: flex; gap: 12px; flex-wrap: wrap;
    }
    .button-group button {
      flex: 1; min-width: 120px;
    }
    .preview-container {
      text-align: center; margin: 16px 0;
    }
    .success-message {
      background: #d4edda; color: #155724; padding: 12px; border-radius: 8px;
      border: 1px solid #c3e6cb; margin-bottom: 16px;
    }
    .error-message {
      background: #f8d7da; color: #721c24; padding: 12px; border-radius: 8px;
      border: 1px solid #f5c6cb; margin-bottom: 16px;
    }
    .meme-card {
      transition: transform 0.2s ease; margin-bottom: 16px;
    }
    .meme-card:hover {
      transform: translateY(-4px);
    }
    @media (max-width: 768px) {
      .row { grid-template-columns: 1fr; }
      h1 { font-size: 2em; }
      .card { padding: 16px; }
      .button-group { flex-direction: column; }
      .button-group button { width: 100%; }
    }
  </style>
  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

    const SUPABASE_URL = 'https://ycmozdaoyqarwwpxudxa.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InljbW96ZGFveXFhcnd3cHh1ZHhhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3MTkyNTgsImV4cCI6MjA3MTI5NTI1OH0.nFCCRHbEWibEfS5fdV77s0iyaxr8TsG0q-LRdK0zhAg';
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Custom Auth System
    class CustomAuth {
      constructor() {
        this.currentUser = null;
        this.sessionKey = 'meme_forge_session';
        this.loadSession();
      }

      // Generate a simple hash (in production, use proper bcrypt)
      async hashPassword(password) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password + 'meme_forge_salt');
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      }

      generateUserId() {
        return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      generateSessionToken() {
        return 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 16);
      }

      saveSession(user, token) {
        const session = { user, token, expires: Date.now() + (7 * 24 * 60 * 60 * 1000) }; // 7 days
        localStorage.setItem(this.sessionKey, JSON.stringify(session));
        this.currentUser = user;
      }

      loadSession() {
        try {
          const stored = localStorage.getItem(this.sessionKey);
          if (!stored) return false;
          const session = JSON.parse(stored);
          if (session.expires < Date.now()) {
            this.clearSession();
            return false;
          }
          this.currentUser = session.user;
          return true;
        } catch {
          this.clearSession();
          return false;
        }
      }

      clearSession() {
        localStorage.removeItem(this.sessionKey);
        this.currentUser = null;
      }

      isAuthenticated() {
        return this.currentUser !== null;
      }

      getCurrentUser() {
        return this.currentUser;
      }

      async signUp(email, password) {
        try {
          const hashedPassword = await this.hashPassword(password);
          const userId = this.generateUserId();
          
          // Check if user already exists
          const { data: existing } = await supabase
            .from('users')
            .select('id')
            .eq('email', email.toLowerCase())
            .single();
          
          if (existing) {
            throw new Error('User already exists with this email');
          }

          // Create user record
          const { data, error } = await supabase
            .from('users')
            .insert({
              id: userId,
              email: email.toLowerCase(),
              password_hash: hashedPassword,
              created_at: new Date().toISOString()
            })
            .select()
            .single();

          if (error) throw error;

          // Create profile record
          const { error: profileError } = await supabase
            .from('profiles')
            .insert({
              user_id: userId,
              email: email.toLowerCase()
            });

          if (profileError) {
            console.warn('Profile creation failed:', profileError.message);
            // Don't fail the signup if profile creation fails
          }

          return { success: true, user: data };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }

      async signIn(email, password) {
        try {
          const hashedPassword = await this.hashPassword(password);
          
          const { data, error } = await supabase
            .from('users')
            .select('*')
            .eq('email', email.toLowerCase())
            .eq('password_hash', hashedPassword)
            .single();

          if (error || !data) {
            throw new Error('Invalid email or password');
          }

          const sessionToken = this.generateSessionToken();
          const user = { id: data.id, email: data.email };
          
          this.saveSession(user, sessionToken);
          return { success: true, user };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }

      signOut() {
        this.clearSession();
        return { success: true };
      }

      async resetPassword(email, newPassword) {
        try {
          const hashedPassword = await this.hashPassword(newPassword);
          
          const { error } = await supabase
            .from('users')
            .update({ password_hash: hashedPassword })
            .eq('email', email.toLowerCase());

          if (error) throw error;
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
    }

    const auth = new CustomAuth();
    let currentUserId = auth.getCurrentUser()?.id || null;

    // ---------- Elements ----------
    const $ = (q) => document.querySelector(q);
    const authView = $('#authView');
    const setupView = $('#setupView');
    const verifyView = $('#verifyView');
    const appView = $('#appView');
    const resetView = $('#resetView');

    // Auth
    const emailIn = $('#email'); const passIn = $('#pass');
    const signUpBtn = $('#signUp'); const signInBtn = $('#signIn'); const signOutBtn = $('#signOut');
    const forgotBtn = $('#forgotPassword');
    
    // Password reset
    const resetEmailIn = $('#resetEmail');
    const sendResetBtn = $('#sendReset');
    const backToAuthBtn = $('#backToAuth');
    const resetTpl = $('#resetTpl');
    const resetTop = $('#resetTop');
    const resetBot = $('#resetBot');
    const resetMid = $('#resetMid');
    const resetMidWrap = $('#resetMidWrap');
    const resetPrev = $('#resetPrev');
    const verifyMemeBtn = $('#verifyMeme');
    const newPassIn = $('#newPassword');
    const confirmPassIn = $('#confirmPassword');
    const updatePassBtn = $('#updatePassword');

  // Meme password setup
  const sTpl = $('#sTpl'), sTop = $('#sTop'), sBot = $('#sBot'), sSave = $('#sSave');
  const sMidWrap = document.getElementById('sMidWrap');
  const sMid = document.getElementById('sMid');

  // Meme password verify each login
  const vTpl = $('#vTpl'), vTop = $('#vTop'), vBot = $('#vBot'), vCheck = $('#vCheck');
  const vMidWrap = document.getElementById('vMidWrap');
  const vMid = document.getElementById('vMid');
  // Previews for setup/verify
  const sPrev = document.getElementById('sPrev');
  const vPrev = document.getElementById('vPrev');

    // Editor
    const tSelect = $('#template'); const topIn = $('#top'); const botIn = $('#bottom');
    const canvas = $('#c'); const ctx = canvas.getContext('2d');
  const publishBtn = $('#publish'); const feed = $('#feed');
  const midIn = document.getElementById('middle');
  const midWrap = document.getElementById('middleWrap');
  // copyLayout button removed

    // Templates (add your files in /templates)
    const templates = {
      drake: 'templates/drake.jpg',
      distracted: 'templates/distracted.jpg',
      doge: 'templates/doge.jpg'
    };
      // Layout configuration (locked positions) per template
      const templateLayouts = {
        drake: { top:{x:0.73,y:0.18}, bottom:{x:0.73,y:0.72} },
  distracted: { top:{x:0.22,y:0.55}, mid:{x:0.58,y:0.45}, bottom:{x:0.80,y:0.82} },
        doge: { top:{x:0.48,y:0.02}, bottom:{x:0.49,y:0.80} }
      };
      const LOCK_TEMPLATE_SLOTS = false; // Option B selected

    // ---------- Small preview helpers (for setup/verify) ----------
    function bindPreview(tplSel, topEl, botEl, canvasEl, midEl) {
      if (!tplSel || !topEl || !botEl || !canvasEl) return;
      let img = new Image();
      function drawPreview() {
        if (!img.complete) return;
        const srcW = img.width || 600, srcH = img.height || 600;
        const maxW = 420;
        const w = Math.min(maxW, srcW);
        const scale = w / srcW;
        const h = Math.round(srcH * scale);
        canvasEl.width = w; canvasEl.height = h;
        const ctx2 = canvasEl.getContext('2d');
        ctx2.clearRect(0,0,w,h);
        ctx2.drawImage(img, 0, 0, w, h);
        ctx2.font = `${Math.floor(w/12)}px Impact, Arial Black, sans-serif`;
        ctx2.fillStyle = 'white'; ctx2.textAlign='center';
        ctx2.lineWidth = Math.ceil(w/200); ctx2.strokeStyle='black';
        const lineH = parseInt(ctx2.font,10) + 6;
        const fontSize = parseInt(ctx2.font,10);
        const drawBlock = (text, cx, topY) => {
          const t = (text||'').trim().toUpperCase(); if (!t) return;
          const words = t.split(/\s+/);
            let line = '', lines = [];
            for (const w2 of words) {
              const test = line ? line + ' ' + w2 : w2;
              if (ctx2.measureText(test).width > w*0.9) { if (line) lines.push(line); line = w2; }
              else line = test;
            }
            if (line) lines.push(line);
            lines.forEach((ln,i)=>{
              const yy = topY + fontSize + i*lineH;
              ctx2.strokeText(ln, cx, yy);
              ctx2.fillText(ln, cx, yy);
            });
        };
        const layout = templateLayouts[tplSel.value];
        if (layout) {
          if (layout.top) drawBlock(topEl.value, layout.top.x * w, layout.top.y * h);
          if (layout.mid && midEl) drawBlock(midEl.value, layout.mid.x * w, layout.mid.y * h);
          if (layout.bottom) drawBlock(botEl.value, layout.bottom.x * w, layout.bottom.y * h);
        } else {
          // fallback to legacy pad positions
          const pad = Math.floor(h*0.06);
          drawBlock(topEl.value, 0.5 * w, pad);
          drawBlock(botEl.value, 0.5 * w, h - pad - fontSize - lineH);
        }
      }
      function loadImage() {
        img = new Image();
        img.onload = drawPreview;
        img.src = templates[tplSel.value];
      }
      tplSel.addEventListener('change', loadImage);
      topEl.addEventListener('input', drawPreview);
      botEl.addEventListener('input', drawPreview);
      if (midEl) midEl.addEventListener('input', drawPreview);
      loadImage();
    }

    // ---------- UI state ----------
    async function refreshSession() {
      // Check if this is a password reset flow
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('type') === 'recovery') {
        show(resetView);
        // Show meme verification form first, not password form
        document.getElementById('resetEmailForm').style.display = 'none';
        document.getElementById('resetMemeForm').style.display = 'block';
        document.getElementById('resetPasswordForm').style.display = 'none';
        return;
      }
      
      if (!auth.isAuthenticated()) return show(authView);
      // cache current user id
      currentUserId = auth.getCurrentUser().id;

      // does user have meme secret saved?
      const { data: prof } = await supabase.from('profiles').select('meme_template_key').eq('user_id', currentUserId).single();
      if (!prof || !prof.meme_template_key) {
        show(setupView);
        return;
      }
      // force verify on every login (and also on refresh if you want)
      show(verifyView);
    }

    function show(view) {
      [authView, setupView, verifyView, appView, resetView].forEach(v => v.classList.add('hidden'));
      view.classList.remove('hidden');
      // toggle Sign Out visibility (only when logged in views are shown)
      if (view === authView || view === resetView) signOutBtn.classList.add('hidden');
      else signOutBtn.classList.remove('hidden');
    }

    // ---------- Auth ----------
    signUpBtn.onclick = async () => {
      const result = await auth.signUp(emailIn.value, passIn.value);
      if (result.error) return alert(result.error);
      currentUserId = result.user.id;
      show(setupView);
    };
    signInBtn.onclick = async () => {
      const result = await auth.signIn(emailIn.value, passIn.value);
      if (result.error) return alert(result.error);
      currentUserId = result.user.id;
      show(verifyView);
    };
    signOutBtn.onclick = async () => {
      auth.signOut();
      currentUserId = null;
      show(authView);
    };

    // ---------- Password Reset ----------
    forgotBtn.onclick = async () => {
      show(resetView);
    };

    backToAuthBtn.onclick = () => {
      show(authView);
    };

    sendResetBtn.onclick = async () => {
      if (!resetEmailIn.value) {
        alert('Please enter your email address.');
        return;
      }
      
      // Check if user exists
      const { data: user } = await supabase
        .from('users')
        .select('id')
        .eq('email', resetEmailIn.value.toLowerCase())
        .single();
        
      if (!user) {
        alert('No account found with this email address.');
        return;
      }
      
      // Store email for reset process
      window.resetEmail = resetEmailIn.value.toLowerCase();
      
      // Show meme verification form directly (no email link needed)
      document.getElementById('resetEmailForm').style.display = 'none';
      document.getElementById('resetMemeForm').style.display = 'block';
      alert('Please verify your meme password to proceed with password reset.');
    };

    verifyMemeBtn.onclick = async () => {
      if (!window.resetEmail) {
        alert('Reset session expired. Please start over.');
        show(authView);
        return;
      }
      
      const argsBase = { 
        template_key: resetTpl.value, 
        top_text: resetTop.value, 
        bottom_text: resetBot.value,
        user_email: window.resetEmail  // Pass email to verify for correct user
      };
      const args = (resetTpl.value === 'distracted' && resetMid) ? { ...argsBase, mid_text: resetMid.value } : argsBase;
      let { data, error } = await supabase.rpc('verify_meme_secret', args);
      if (error && args.mid_text) { // fallback
        ({ data, error } = await supabase.rpc('verify_meme_secret', argsBase));
      }
      if (error) return alert(error.message);
      if (!data) return alert('Meme password is wrong. Cannot proceed with password reset.');
      
      // Meme verified, show password form
      document.getElementById('resetMemeForm').style.display = 'none';
      document.getElementById('resetPasswordForm').style.display = 'block';
    };

    updatePassBtn.onclick = async () => {
      if (!newPassIn.value || !confirmPassIn.value) {
        alert('Please fill in both password fields.');
        return;
      }
      if (newPassIn.value !== confirmPassIn.value) {
        alert('Passwords do not match.');
        return;
      }
      if (newPassIn.value.length < 6) {
        alert('Password must be at least 6 characters long.');
        return;
      }
      
      if (!window.resetEmail) {
        alert('Reset session expired. Please start over.');
        show(authView);
        return;
      }
      
      const result = await auth.resetPassword(window.resetEmail, newPassIn.value);
      if (!result.success) return alert(result.error);
      
      // Clear reset session
      delete window.resetEmail;
      
      alert('Password updated successfully! You can now sign in with your new password.');
      show(authView);
    };

    // ---------- Meme password setup (once) ----------
    sSave.onclick = async () => {
      if (!currentUserId) {
        alert('User session expired. Please sign in again.');
        show(authView);
        return;
      }
      
      const argsBase = { 
        template_key: sTpl.value, 
        top_text: sTop.value, 
        bottom_text: sBot.value,
        user_id: currentUserId
      };
      const args = (sTpl.value === 'distracted' && sMid) ? { ...argsBase, mid_text: sMid.value } : argsBase;
      let { error } = await supabase.rpc('set_meme_secret', args);
      if (error && args.mid_text) { // fallback if RPC not updated yet
        ({ error } = await supabase.rpc('set_meme_secret', argsBase));
      }
      if (error) return alert(error.message);
      alert('Meme password saved!');
      show(verifyView);
    };

    // ---------- Verify meme password (each login) ----------
    vCheck.onclick = async () => {
      if (!currentUserId) {
        alert('User session expired. Please sign in again.');
        show(authView);
        return;
      }
      
      const argsBase = { 
        template_key: vTpl.value, 
        top_text: vTop.value, 
        bottom_text: vBot.value,
        user_id: currentUserId
      };
      const args = (vTpl.value === 'distracted' && vMid) ? { ...argsBase, mid_text: vMid.value } : argsBase;
      let { data, error } = await supabase.rpc('verify_meme_secret', args);
      if (error && args.mid_text) { // fallback
        ({ data, error } = await supabase.rpc('verify_meme_secret', argsBase));
      }
      if (error) return alert(error.message);
      if (!data) return alert('Meme password is wrong.');
      show(appView);
      initApp();
    };

    // ---------- Meme editor ----------
  let img = new Image();
  // active slot positions (copied from templateLayouts on template change)
  let posTop = { x: 0.5, y: 0.08 };
  let posMid = { x: 0.5, y: 0.50 };
  let posBot = { x: 0.5, y: 0.88 };
  // last computed bounding boxes for hit-testing
  let topBox = null, midBox = null, botBox = null;
  // dragging state
  const drag = { which: null, dx: 0, dy: 0 };

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function draw() {
      if (!img.complete) return;
      const w = img.width, h = img.height;
      canvas.width = w; canvas.height = h;
      ctx.drawImage(img, 0, 0, w, h);
      ctx.font = `${Math.floor(w/10)}px Impact, Arial Black, sans-serif`;
      ctx.fillStyle = 'white'; ctx.textAlign='center';
      ctx.lineWidth = Math.ceil(w/200); ctx.strokeStyle='black';
      const lineH = parseInt(ctx.font,10) + 6;
      const fontSize = parseInt(ctx.font,10);

      const drawBlock = (text, cx, topY) => {
        const t = (text || '').trim().toUpperCase();
        if (!t) return null;
        const words = t.split(/\s+/);
        let line = '', lines = [];
        for (const w2 of words) {
          const test = line ? line + ' ' + w2 : w2;
          if (ctx.measureText(test).width > w*0.9) { if (line) lines.push(line); line = w2; }
          else line = test;
        }
        if (line) lines.push(line);
        let maxW = 0;
        for (const ln of lines) maxW = Math.max(maxW, ctx.measureText(ln).width);
        // draw lines
        lines.forEach((ln,i)=>{
          const yy = topY + fontSize + i*lineH; // baseline position per line
          ctx.strokeText(ln, cx, yy);
          ctx.fillText(ln, cx, yy);
        });
        return { x: cx - maxW/2, y: topY, w: maxW, h: lines.length * lineH };
      };

      topBox = drawBlock(topIn.value, posTop.x * w, posTop.y * h);
      midBox = (midWrap && !midWrap.classList.contains('hidden') && midIn) ? drawBlock(midIn.value, posMid.x * w, posMid.y * h) : null;
  botBox = drawBlock(botIn.value, posBot.x * w, posBot.y * h);
    }
    function loadTemplate(key) { img = new Image(); img.onload = draw; img.src = templates[key]; }

    function setDefaultPositionsForTemplate(key){
      const layout = templateLayouts[key];
      if (!layout) return;
      if (layout.top) posTop = { ...layout.top };
      if (layout.mid) posMid = { ...layout.mid };
      if (layout.bottom) posBot = { ...layout.bottom };
    }
    function toggleMiddleForTemplate(key){
      if (!midWrap) return;
      if (key === 'distracted') midWrap.classList.remove('hidden'); else midWrap.classList.add('hidden');
    }
    tSelect.onchange = () => { setDefaultPositionsForTemplate(tSelect.value); toggleMiddleForTemplate(tSelect.value); loadTemplate(tSelect.value); };
    topIn.oninput = draw; botIn.oninput = draw; if (midIn) midIn.oninput = draw;
    toggleMiddleForTemplate(tSelect.value);
    setDefaultPositionsForTemplate(tSelect.value);
    loadTemplate(tSelect.value);

    // ----- Dragging for positioning -----
    function toCanvasXY(e) {
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top) * (canvas.height / r.height);
      return { x, y };
    }
    function inBox(pt, box) {
      if (!box) return false;
      return pt.x >= box.x && pt.x <= box.x + box.w && pt.y >= box.y && pt.y <= box.y + box.h;
    }
    function updateCursor(e){
      const pt = toCanvasXY(e);
  if (!LOCK_TEMPLATE_SLOTS && (inBox(pt, topBox) || inBox(pt, botBox) || inBox(pt, midBox))) canvas.style.cursor = 'move';
      else canvas.style.cursor = '';
    }
    canvas.addEventListener('mousemove', (e)=>{
      if (!drag.which) { updateCursor(e); return; }
      const { x, y } = toCanvasXY(e);
      const w = canvas.width, h = canvas.height;
  if (drag.which === 'top') {
        posTop.x = clamp((x - drag.dx)/w, 0, 1);
        posTop.y = clamp((y - drag.dy)/h, 0, 1);
      } else if (drag.which === 'mid') {
        posMid.x = clamp((x - drag.dx)/w, 0, 1);
        posMid.y = clamp((y - drag.dy)/h, 0, 1);
      } else if (drag.which === 'bot') {
        posBot.x = clamp((x - drag.dx)/w, 0, 1);
        posBot.y = clamp((y - drag.dy)/h, 0, 1);
      }
      draw();
    });
    canvas.addEventListener('mousedown', (e)=>{
      const { x, y } = toCanvasXY(e);
      const w = canvas.width, h = canvas.height;
  if (!LOCK_TEMPLATE_SLOTS && inBox({x,y}, topBox)) {
        drag.which = 'top';
        drag.dx = x - posTop.x * w; drag.dy = y - posTop.y * h;
  } else if (!LOCK_TEMPLATE_SLOTS && inBox({x,y}, midBox)) {
        drag.which = 'mid';
        drag.dx = x - posMid.x * w; drag.dy = y - posMid.y * h;
  } else if (!LOCK_TEMPLATE_SLOTS && inBox({x,y}, botBox)) {
        drag.which = 'bot';
        drag.dx = x - posBot.x * w; drag.dy = y - posBot.y * h;
      } else {
        drag.which = null;
      }
    });
    ['mouseup','mouseleave'].forEach(ev => canvas.addEventListener(ev, ()=>{ drag.which = null; }));

  // (Reset positions UI removed)

    // ---------- Layout debug / exposure ----------
    // Expose getters & setters so you can inspect via DevTools
    window.memeLayoutAPI = {
      get() { return { template: tSelect.value, top: { ...posTop }, mid: { ...posMid }, bottom: { ...posBot } }; },
      set(p) {
        if (p.top) posTop = { ...posTop, ...p.top };
        if (p.mid) posMid = { ...posMid, ...p.mid };
        if (p.bottom) posBot = { ...posBot, ...p.bottom };
        draw();
      },
      log() { console.log('[memeLayout]', this.get()); }
    };
  // copy layout button removed (use memeLayoutAPI.log() or memeLayoutAPI.get() in console)
    // Hotkey Alt+L to log current layout
    window.addEventListener('keydown', (e)=>{ if (e.altKey && e.key.toLowerCase()==='l') window.memeLayoutAPI.log(); });


    // ---------- Publish & Feed ----------
    async function publish() {
      publishBtn.disabled = true;
      try {
        const user = auth.getCurrentUser();
        if (!user || !user.id) {
          alert('You must be logged in to publish. Please refresh and sign in.');
          return;
        }

        const blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.95));
        const fileName = `memes/${Date.now()}.png`;
        const { data: upload, error: upErr } = await supabase.storage.from('memes').upload(fileName, blob, {
          contentType: 'image/png', upsert: false
        });
        if (upErr) throw upErr;
        const { data: url } = supabase.storage.from('memes').getPublicUrl(upload.path);

        const { error: dbErr } = await supabase.from('memes').insert({
          author_id: user.id,
          template_key: tSelect.value,
          top_text: topIn.value,
          bottom_text: botIn.value,
          image_url: url.publicUrl
        });
        if (dbErr) throw dbErr;

        alert('Published!');
      } catch (e) {
        alert(e.message);
      } finally {
        publishBtn.disabled = false;
      }
    }
    publishBtn.onclick = publish;

    async function toggleLike(memeId) {
      console.log('toggleLike called with memeId:', memeId); // Debug: Function entry
      const user = auth.getCurrentUser();
      console.log('Current user:', user); // Debug: Check user
      if (!user || !user.id) {
        console.error("toggleLike failed: user not found. Please sign in.");
        alert('You must be signed in to like a post.');
        return;
      }
      const userId = user.id;

      // Check if a "like" record already exists from this user for this meme.
      // We select 'meme_id' because we know it exists. We just need to see if a row is returned.
      const { data: existingLike, error } = await supabase
        .from('likes')
        .select('meme_id') 
        .eq('meme_id', memeId)
        .eq('user_id', userId)
        .maybeSingle(); // Use maybeSingle to avoid an error if no row is found.

      if (error) {
        console.error('Error checking for like:', error);
        alert(`Error checking for like: ${error.message}`);
        return;
      }

      if (existingLike) {
        // If a like exists, delete it using the user_id and meme_id pair.
        const { error: deleteError } = await supabase.from('likes').delete()
          .eq('meme_id', memeId)
          .eq('user_id', userId);
        if (deleteError) {
          console.error('Error unliking:', deleteError);
          alert(`Error unliking: ${deleteError.message}`);
        }
      } else {
        // If no like exists, insert a new one.
        const { error: insertError } = await supabase.from('likes').insert({ meme_id: memeId, user_id: userId });
        if (insertError) {
          console.error('Error liking:', insertError);
          alert(`Error liking: ${insertError.message}`);
        }
      }
    }

    async function initApp() {
      // Ensure user state is fresh before fetching data
      currentUserId = auth.getCurrentUser()?.id || null;

      // Fetch initial leaderboard data
      const { data, error } = await supabase.from('meme_leaderboard')
        .select('*').order('like_count', { ascending: false }).limit(50);
      if (error) return alert(error.message);
      
      renderFeed(data);

      // Set up a real-time subscription to automatically refresh the feed on any change
      const refreshFeed = async (payload) => {
        console.log('Database change detected, refreshing feed...', payload);
        const { data: updatedData, error: fetchError } = await supabase.from('meme_leaderboard')
          .select('*').order('like_count', { ascending: false }).limit(50);
        if (fetchError) {
          console.error('Error refetching leaderboard after change:', fetchError);
        } else {
          console.log('Feed refreshed successfully');
          renderFeed(updatedData);
        }
      };

      // Listen for changes in both memes and likes tables
      supabase.channel('all-changes')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'memes' }, refreshFeed)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'likes' }, refreshFeed)
        .subscribe((status) => {
          console.log('Real-time subscription status:', status);
        });
    }

    function renderFeed(items) {
      feed.innerHTML = '';
      items.forEach(m => {
        const card = document.createElement('div'); 
        card.className = 'card meme-card';
        const rowId = m.meme_id ?? m.id;
        const canDelete = currentUserId && m.author_id === currentUserId && rowId != null;
        card.innerHTML = `
          <img src="${m.image_url}" alt="Meme"/>
          <div class="likes">
            <button data-like="${rowId}">â¤ï¸ ${m.like_count ?? 0}</button>
            ${canDelete ? `<button data-del="${rowId}" class="danger-btn">ğŸ—‘ï¸ Delete</button>` : ''}
          </div>`;
        feed.appendChild(card);
      });
    }

    feed.addEventListener('click', async (e)=>{
      console.log('Feed clicked!', e.target); // Debug: Check if click is detected
      const likeBtn = e.target.closest('button[data-like]');
      const delBtn = e.target.closest('button[data-del]');
      console.log('Like button found:', likeBtn); // Debug: Check if like button is found
      console.log('Delete button found:', delBtn); // Debug: Check if delete button is found
      if (!likeBtn && !delBtn) return;
      
      const targetBtn = likeBtn || delBtn;
      targetBtn.disabled = true;

      try {
        if (likeBtn) {
          const memeId = likeBtn.dataset.like;
          console.log('About to toggle like for meme ID:', memeId); // Debug: Check meme ID
          await toggleLike(memeId);
          // Manual refresh after like action to ensure UI updates
          console.log('Manually refreshing feed after like action...');
          const { data } = await supabase.from('meme_leaderboard')
            .select('*').order('like_count', { ascending: false }).limit(50);
          renderFeed(data);
        } else if (delBtn) {
          const memeId = delBtn.dataset.del;
          if (!memeId) { alert('Cannot determine meme id for deletion.'); return; }
          if (!confirm('Delete this meme? This cannot be undone.')) return;
          
          const { error: rpcErr } = await supabase.rpc('delete_user_meme', { meme_id: memeId });
          if (rpcErr) {
            alert('Delete failed: ' + rpcErr.message);
          }
        }
      } finally {
        targetBtn.disabled = false;
      }
    });

    // On load
  // bind previews and then refresh session
  bindPreview(sTpl, sTop, sBot, sPrev, sMid);
  bindPreview(vTpl, vTop, vBot, vPrev, vMid);
  bindPreview(resetTpl, resetTop, resetBot, resetPrev, resetMid);
  function togglePasswordMid(sel, wrap){ if(!sel||!wrap) return; if(sel.value==='distracted') wrap.classList.remove('hidden'); else wrap.classList.add('hidden'); }
  sTpl.addEventListener('change', ()=> togglePasswordMid(sTpl, sMidWrap));
  vTpl.addEventListener('change', ()=> togglePasswordMid(vTpl, vMidWrap));
  resetTpl.addEventListener('change', ()=> togglePasswordMid(resetTpl, resetMidWrap));
  togglePasswordMid(sTpl, sMidWrap); togglePasswordMid(vTpl, vMidWrap); togglePasswordMid(resetTpl, resetMidWrap);
  refreshSession();
  </script>
</head>
<body>
  <h1>ğŸ­ Meme Forge</h1>
  <p class="subtitle">Create, Share & Battle Epic Memes</p>
  <div class="toolbar">
    <button id="signOut" class="hidden">ğŸ‘‹ Sign Out</button>
  </div>

  <!-- AUTH -->
  <div id="authView" class="card">
    <h3>ğŸš€ Welcome to Meme Forge</h3>
    <div class="form-group">
      <label for="email">Email Address</label>
      <input id="email" placeholder="Enter your email" type="email">
    </div>
    <div class="form-group">
      <label for="pass">Password</label>
      <input id="pass" placeholder="Enter your password" type="password">
    </div>
    <div class="button-group">
      <button id="signUp">âœ¨ Sign Up</button>
      <button id="signIn">ğŸ”‘ Sign In</button>
    </div>
    <button id="forgotPassword" class="secondary-btn">ğŸ”„ Forgot Password?</button>
  </div>

  <!-- PASSWORD RESET -->
  <div id="resetView" class="card hidden">
    <h3>ğŸ”„ Reset Password</h3>
    <div id="resetEmailForm">
      <p>Enter your email address to receive a password reset link:</p>
      <div class="form-group">
        <label for="resetEmail">Email Address</label>
        <input id="resetEmail" placeholder="Enter your email" type="email">
      </div>
      <div class="button-group">
        <button id="sendReset">ğŸ“§ Send Reset Link</button>
        <button id="backToAuth" class="secondary-btn">â† Back to Sign In</button>
      </div>
    </div>
    <div id="resetMemeForm" style="display:none">
      <p>ğŸ›¡ï¸ First, verify your meme password to confirm your identity:</p>
      <div class="form-group">
        <label for="resetTpl">Template</label>
        <select id="resetTpl">
          <option value="drake">ğŸ¦† Drake Pointing</option>
          <option value="distracted">ğŸ‘€ Distracted Boyfriend</option>
          <option value="doge">ğŸ• Doge</option>
        </select>
      </div>
      <div class="form-group">
        <label for="resetTop">Top Text</label>
        <input id="resetTop" placeholder="Enter top text">
      </div>
      <div id="resetMidWrap" class="form-group hidden">
        <label for="resetMid">Middle Text</label>
        <input id="resetMid" placeholder="Enter middle text (distracted only)">
      </div>
      <div class="form-group">
        <label for="resetBot">Bottom Text</label>
        <input id="resetBot" placeholder="Enter bottom text">
      </div>
      <div class="preview-container">
        <canvas id="resetPrev" title="Preview"></canvas>
      </div>
      <button id="verifyMeme">âœ… Verify Meme Password</button>
    </div>
    <div id="resetPasswordForm" style="display:none">
      <div class="success-message">âœ… Meme password verified! Now enter your new account password:</div>
      <div class="form-group">
        <label for="newPassword">New Password</label>
        <input id="newPassword" placeholder="Enter new password" type="password">
      </div>
      <div class="form-group">
        <label for="confirmPassword">Confirm Password</label>
        <input id="confirmPassword" placeholder="Confirm new password" type="password">
      </div>
      <button id="updatePassword">ğŸ” Update Password</button>
    </div>
  </div>

  <!-- SETUP MEME PASSWORD (once) -->
  <div id="setupView" class="card hidden">
    <h3>ğŸ›¡ï¸ Set Your Meme Password</h3>
    <p>Create a unique meme-based password for extra security!</p>
    <div class="form-group">
      <label for="sTpl">Choose Template</label>
      <select id="sTpl">
        <option value="drake">ğŸ¦† Drake Pointing</option>
        <option value="distracted">ğŸ‘€ Distracted Boyfriend</option>
        <option value="doge">ğŸ• Doge</option>
      </select>
    </div>
    <div class="form-group">
      <label for="sTop">Top Text</label>
      <input id="sTop" placeholder="Enter top text">
    </div>
    <div id="sMidWrap" class="form-group hidden">
      <label for="sMid">Middle Text</label>
      <input id="sMid" placeholder="Enter middle text (distracted only)">
    </div>
    <div class="form-group">
      <label for="sBot">Bottom Text</label>
      <input id="sBot" placeholder="Enter bottom text">
    </div>
    <div class="preview-container">
      <canvas id="sPrev" title="Preview"></canvas>
    </div>
    <button id="sSave">ğŸ’¾ Save Meme Password</button>
  </div>

  <!-- VERIFY MEME PASSWORD (every login) -->
  <div id="verifyView" class="card hidden">
    <h3>ğŸ” Verify Your Meme Password</h3>
    <p>Enter your meme password to access the app</p>
    <div class="form-group">
      <label for="vTpl">Template</label>
      <select id="vTpl">
        <option value="drake">ğŸ¦† Drake Pointing</option>
        <option value="distracted">ğŸ‘€ Distracted Boyfriend</option>
        <option value="doge">ğŸ• Doge</option>
      </select>
    </div>
    <div class="form-group">
      <label for="vTop">Top Text</label>
      <input id="vTop" placeholder="Enter top text">
    </div>
    <div id="vMidWrap" class="form-group hidden">
      <label for="vMid">Middle Text</label>
      <input id="vMid" placeholder="Enter middle text (distracted only)">
    </div>
    <div class="form-group">
      <label for="vBot">Bottom Text</label>
      <input id="vBot" placeholder="Enter bottom text">
    </div>
    <div class="preview-container">
      <canvas id="vPrev" title="Preview"></canvas>
    </div>
    <button id="vCheck">âœ… Verify & Continue</button>
  </div>

  <!-- APP -->
  <div id="appView" class="hidden">
    <div class="row">
      <div class="card">
        <h3>ğŸ¨ Create Your Meme</h3>
        <div class="form-group">
          <label for="template">Choose Template</label>
          <select id="template">
            <option value="drake">ğŸ¦† Drake Pointing</option>
            <option value="distracted">ğŸ‘€ Distracted Boyfriend</option>
            <option value="doge">ğŸ• Doge</option>
          </select>
        </div>
        <div class="form-group">
          <label for="top">Top Text</label>
          <input id="top" placeholder="Enter top text" />
        </div>
        <div id="middleWrap" class="form-group hidden">
          <label for="middle">Middle Text</label>
          <input id="middle" placeholder="Enter middle text (distracted only)" />
        </div>
        <div class="form-group">
          <label for="bottom">Bottom Text</label>
          <input id="bottom" placeholder="Enter bottom text" />
        </div>
        <div class="preview-container">
          <canvas id="c"></canvas>
        </div>
        <button id="publish">ğŸš€ Publish Meme</button>
      </div>
      <div>
        <div class="card">
          <h3>ğŸ† Meme Leaderboard</h3>
          <p>Top memes by likes</p>
          <div id="feed"></div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
